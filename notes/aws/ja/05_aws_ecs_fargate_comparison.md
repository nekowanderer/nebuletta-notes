# ECS、Fargate、Lambda、EKS の比較と Sidecar 設計の説明

[English](../en/05_aws_ecs_fargate_comparison.md) | [繁體中文](../zh-tw/05_aws_ecs_fargate_comparison.md) | [日本語](05_aws_ecs_fargate_comparison.md) | [インデックスに戻る](../README.md)

## EC2 vs Fargate

| 側面 | EC2 | Fargate |
|------|-----|---------|
| 本質 | VM（仮想マシン） | サーバーレスコンテナ実行環境 |
| 制御権 | VMの自己管理（更新、監視、パッチ適用） | AWSがインフラを管理、コンテナ設定のみ担当 |
| コスト構造 | 長時間稼働で無駄なコストが発生する可能性 | 実際の使用時間のみ課金、より効率的 |
| 運用責任 | OSのパッチ適用、リソース調整などが必要 | AWSが自動管理、開発者はアプリケーションロジックに集中 |
| 適したシナリオ | 長時間稼働、特殊な要件 | タスクベースの作業、自動スケーリングが必要な場合 |

### 使用ケース
- EC2が適している場合：
  - 環境の完全な制御が必要
  - 特殊なカーネルモジュールが必要なアプリケーション
  - 長時間稼働、またはコンテナ化が難しいプログラム
  - リネージュで召喚されたバグベアーのような存在
- Fargateが適している場合：
  - 短時間タスク、イベント駆動のコンピューティング
  - 迅速な起動と終了（バッチ処理など）
  - ホスト管理を避け、アプリケーション提供に集中したいチーム
  - 物理的な召喚ユニットなし (?)

---

## ECS on EC2 vs ECS on Fargate

| 比喩 | ECS on EC2 | ECS on Fargate |
|------|------------|----------------|
| 召喚の性質 | 「呼び出したら、部屋と食事の準備が必要」 | 「呼び出したら、自分で部屋を見つけ、弁当を持ってくる」 |
| リソース管理 | EC2インスタンスの自己管理（CPU、RAM、Auto Scaling） | AWSが自動的に必要なリソースを設定、EC2管理不要 |
| コスト | 召喚したら維持が必要（タスク実行の有無に関わらず） | タスク実行時間のみ課金（より従量課金に近い） |
| スケーラビリティ | ASGの設定または手動調整が必要 | ネイティブな弾力性、高度な自動化 |
| 運用責任 | EC2のパッチ適用、リソース圧力、容量見積もりなど全て自己責任 | AWSがインフラを管理、開発者はアプリケーションロジックに集中 |
| 適したシナリオ | コスト管理が明確、特殊な環境要件、長時間稼働 | 小規模チーム、迅速な開発、要件変更が多いシナリオ |

---

## Fargate vs Lambda

| 側面 | Fargate | Lambda |
|------|---------|--------|
| 召喚の性質 | 「タスク全体を処理でき、長期契約も可能」 | 「一度の仕事をして逃げる、精密な暗殺者のような存在」 |
| 起動方法 | 長時間稼働可能なコンテナタスク（バックグラウンドジョブ、API、バッチ） | 通常はイベント駆動（API Gateway、S3、CloudWatchなど） |
| 維持時間 | 数分から数時間まで可能 | 最大15分（デフォルトのコールドスタート） |
| 制御の柔軟性 | Dockerベース、複数の言語とランタイムをサポート | 限られた言語サポート、AWSがサポートするランタイムが必要 |
| 実行コスト | CPUとメモリに基づく計算（設定と時間による） | 関数の実行時間とメモリに基づく課金（ミリ秒単位） |
| 適したシナリオ | ステートフルなタスク、またはより多くのランタイム制御が必要 | ファイル変換、通知、画像リサイズなどの短く精密なタスク |

---

## Auto Scaling Group vs ECS Service Auto Scaling

| 名前 | 管理対象 | 適用場所 | 調整対象 |
|------|----------|----------|----------|
| Auto Scaling Group (ASG) | EC2の数 | ECS on EC2 | VMの数 |
| ECS Service Auto Scaling | タスクの数 | ECS on Fargate / EC2 | コンテナタスクの数 |

### 詳細な説明：
#### Auto Scaling Group (ASG)
- EC2（またはECS on EC2）環境で使用
- 仮想マシンの数を調整
- 例：ASGのmin=2、max=10を設定し、CPU負荷が70%を超えると自動的にEC2インスタンスを追加

#### 使用ケース：
- EC2が主体で、VMのスケーリングが必要な場合
- ECS on EC2で、コンテナがより多くのタスクを実行できない場合、ASGでEC2を追加

#### ECS Service Auto Scaling（Fargate & EC2用）
- ECSタスク数を調整、つまりコンテナインスタンス数
- Target Trackingを設定可能、例：平均CPUを50%に維持、自動的にタスクを追加
- Fargateの場合、新しいタスクはAWSが自動的に配置
- EC2の場合、EC2 VMに空きがあることを確認する必要がある、そうでないとタスクは保留状態

#### 使用ケース：
- コンテナ数を自動的にスケーリングしたい場合
- Fargateでは完全自動化、基盤VMの管理不要
- EC2では、完全な弾力性のためにASGと連携が必要

---

## ECS Task ≠ Container Instance

- Q: では、ECSタスクはコンテナインスタンスと同等ですか？
- A: この表現は注意が必要です。ECSタスク ≠ コンテナインスタンスであり、文脈によっては似て見えることもありますが、実際は異なります。

| 用語 | 説明 | 比喩 |
|------|------|------|
| **ECS Task Definition** | コンテナグループの定義。ここでタスクに必要な各種条件を定義する必要がある。例：計算リソース要件やコンテナイメージ | バックパック製造の設計図、K8sのPodテンプレートとも言える |
| **ECS Task** | タスク定義に基づく「コンテナグループ」の実行インスタンス。<br>1つまたは複数のコンテナを実行可能。 | 🧳「タスクパッケージ」：1つ以上のコンテナを入れた小さなバックパック、呼び出されたら出発、K8sのPodとも考えられる |
| **Container Instance** | この用語は**ECS on EC2でのみ使用**され、ECSに登録されたEC2を意味します。 | 🏠「コンテナホスト」：多くのECSタスクを収容できる家 |
| **FargateにはContainer Instanceがない** | Fargateはサーバーレスで、EC2はありません。タスクはAWSが管理する場所に直接配置されます。 | クラウドアパート：AWSが各タスクに独立した部屋を自動的に割り当て、住所や清掃費を気にする必要なし |

#### 違い
| 質問 | Fargate | ECS on EC2 |
|------|---------|------------|
| Container Instanceはあるか？ | ❌ なし | ✅ あり |
| 1タスクで何個のコンテナを実行？ | タスク定義による、通常1～N個 | 同じ |
| タスクの実行場所は誰が決める？ | AWSが自動的に | ECSスケジューラーがコンテナインスタンスから空きを探す |

---

## Sidecar Pattern の例：Microservice + OTEL + Fluent Bit

#### なぜECSタスクに複数のコンテナが含まれることがあるのか？
なぜなら：
> ECSタスクはタスク定義に基づいて起動され、この定義には複数のコンテナを含めることができます。

この設計はsidecarパターンをサポートし、異なるコンテナが以下を共有できます：
  - 同じネットワーク名前空間
  - 同じストレージ空間（ボリューム）
  - そして一緒にスケジュールされ、一緒に管理される

| コンテナ | 役割 | 機能説明 |
|----------|------|----------|
| 🧩 microservice | メインコンテナ | 実際のビジネスロジックAPIまたはサービス |
| 📈 OTEL Collector | メトリクス/トレースのサイドカー | OpenTelemetry形式のメトリクスとトレースを収集・転送（通常はOTLP over gRPCまたはHTTP） |
| 📤 Fluent Bit | ログのサイドカー | stdoutログを収集し、CloudWatch、S3、Elasticsearchなどのログシンクに転送 |

このアーキテクチャはログ、メトリクス、トレースを分離しながら同じタスクにデプロイし、以下の利点があります：
- 観測性とメインコードの分離：
  - マイクロサービスにログ/トレース/エクスポートのロジックをハードコードする必要なし
  - OTEL CollectorとFluent Bitはインフラチームが保守可能
- 高い再利用性：
  - 複数のマイクロサービスが同じsidecarパターンを使用可能
  - 設定ファイルを微調整するだけで異なる要件に対応
- 低結合、高デプロイ柔軟性：
  - OTEL Collectorをサイドサービスに移行したい場合も容易
- 共有ボリューム、ポート通信、dependsOn設定をサポートし、独立したタスクデプロイメントユニットを形成

#### サイドカーコンテナの一般的な用途

| タイプ | 機能 |
|--------|------|
| Logging | ログをS3、CloudWatch、Elasticsearchに送信 |
| Metrics | Prometheus exporter、Datadog agent |
| Proxy | Envoy、NGINX、Linkerdなどのリバースプロキシ/サービスメッシュ |
| Security | Istio Citadelのような証明書提供、自動更新証明書エージェント |
| Init container（ECSにはない） | K8sのみで利用可能、ECSにはこのメカニズムなし |

---

## ECSはinitContainerとpreStopをサポートしていない

ECSタスクはタスク定義に基づいてコンテナを一緒に起動しますが：

| 機能 | ECSサポート |
|------|------------|
| コンテナ起動順序（`dependsOn`） | ✅ 基本サポート |
| init container（1回限りの初期化コンテナ） | ❌ なし |
| preStop hook / graceful shutdown | ❌ 組み込みサポートなし |
| サイドカーの再起動ポリシー分離 | ❌ なし |
| コンテナのヘルスチェック失敗時にタスク全体を終了 | ✅ 設定可能だが粗い |

したがってECSの設計は：
>「すべてのコンテナは1つのタスクに束縛され、生死を共にする」

K8sのように細かく定義できない：「このコンテナはinitで1回だけ実行、このコンテナの失敗はメインコンテナに影響しない、このコンテナは他の準備ができるまで待つ必要がある」

---

## 細かいライフサイクル制御が必要な場合はAWS EKSを検討

#### EKSを使用すべき場合
| これらの要件がある場合 | EKSを検討 |
|----------------------|-----------|
| コンテナ間の複雑な依存関係 | ✅ |
| 多段階の初期化プロセス | ✅ |
| 強化された観測性、モニタリング、またはネットワークポリシー | ✅ |
| Istio、LinkerdなどのService Meshを統合したい | ✅ |
| コンテナのライフサイクルフックの動作をカスタマイズしたい | ✅ |

#### ライフサイクル
| 機能 | EKSサポート |
|------|------------|
| initContainer | ✅ |
| preStop hook | ✅ |
| Readiness / Liveness probe | ✅ |
| terminationGracePeriod | ✅ |
| Service Mesh / Sidecar decoupling | ✅ |

厳格なコンテナライフサイクル制御と柔軟なアーキテクチャが必要な場合は、AWS EKS（Kubernetesマネージドサービス）の使用を検討してください。

## ECS vs EKS

| 側面 | ECS | EKS |
|------|-----|-----|
| 操作の難しさ | 簡単（"K8s-lite"と見なせる） | より複雑、Kubernetesの学習が必要 |
| コスト | 制御可能、リソース使用がより単純 | 管理コストが高く、複雑性のために追加コストが発生する可能性 |
| スケーリングの柔軟性 | 中程度 | 高く、大規模システムに適している |
| コミュニティとツールチェーン | 主にAWSエコシステム | 世界中のK8sエコシステムのサポート | 